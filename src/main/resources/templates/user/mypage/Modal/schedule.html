<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>My page</title>
    <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap"
            rel="stylesheet"
    />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            background-color: #f7f9fc;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 20px;
            box-shadow: 0 4px 4px rgba(0, 0, 0, 0.1);
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }
        h1 {
            font-size: 2.3rem;
            font-weight: bold;
            color: #2563eb;
            margin: 0;
        }
        h1 a {
            text-decoration: none;
            color: inherit;
        }

        nav a {
            margin-left: 20px;
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.2s ease, font-size 0.2s ease;
        }
        nav a:hover {
            color: #3b82f6;
            font-size: 1.1rem;
        }
        main {
            flex: 1;
            padding: 20px 0;
        }
        .container {
            display: grid;
            grid-template-columns: 2fr 1fr; /* 좌:대표(넓게) / 우:사이드 */
            gap: 16px;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px 16px;
        }

        /* 우측 패널은 세로 스택 */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* 반응형 전환 */
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr; /* 한 줄 */
            }
        }
        .box {
            flex: 1;
            background: #fff;
            border: 1px solid #e2e8f0; /* card 라인 */
            border-radius: 14px;
            padding: 16px 18px;
            box-shadow: 0 6px 18px rgba(2, 6, 23, 0.06);
            display: flex;
            flex-direction: column;
            min-height: 160px;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }
        .box3{
            min-height: 220px;
        }
        .box:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
        }
        /* 박스 간 간격 통일 \*/
        .sidebar .box + .box {
            margin-top: 16px;
        }
        /* 박스 타이틀을 card 헤더처럼 쓰고 싶을 때 */
        .box .card-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0 0 12px;
            font-size: 16px;
            font-weight: 800;
        }
        .box .card-title .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: #e6efff; /* brand-weak 느낌 */
            font-size: 16px;
        }

        /* 텍스트 공통 */
        h2,
        h3 {
            margin: 0 0 10px;
            font-size: 1.1rem;
            color: #111827;
        }
        .section h3 {
            margin-top: 24px; /* “비밀번호 변경” 제목 위로 24px 띄움 */
        }
        .section {
            margin-bottom: 10px;
        }
        .section button {
            display: inline-block;
            width: 120px;
            margin-top: 8px;
            text-align: center;
        }
        /* 회원 설정: 제목과 버튼을 같은 줄에 */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-top: 0px; /* 기존 h3 위 여백 대체 */
        }
        .section-header h3 {
            margin: 0; /* 기본 마진 제거 */
            line-height: 1; /* 높이를 조금 줄여 위로 붙게 */
            transform: translateY(-3px); /* 위로 3px 이동 (원하면 -2~ -5로 조절) */
        }

        /* 버튼 묶음 (우측) */
        .section-header .actions {
            display: flex;
            gap: 8px;
        }

        /* 기존 .section button { width:120px } 같은 규칙을 무력화 */
        .section-header .actions button {
            width: auto;
            margin-top: 0;
            padding: 8px 12px; /* 컴팩트 */
        }

        /* 화면 좁을 때는 자연스럽게 줄바꿈 */
        @media (max-width: 560px) {
            .section-header {
                flex-wrap: wrap;
            }
            .section-header .actions {
                width: 100%;
                justify-content: flex-start;
            }
        }

        .info p {
            margin: 3px 0;
            font-size: 0.9rem;
            color: #374151;
        }
        button {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        button:hover {
            background-color: #1e40af;
            transform: scale(1.03);
        }
        button.red {
            background-color: #ef4444;
        }
        button.red:hover {
            background-color: #dc2626;
        }
        .representative-container {
            width: 100%;
            display: block; /* 중앙정렬 플렉스 제거 */
            margin-top: 0;
        }
        .representative-box {
            width: auto; /* 70% 제한 해제 */
            max-width: none; /* 1000px 제한 해제(필요 시 복원 가능) \*/
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            padding: 30px;
            box-sizing: border-box;
            max-height: 775px;
            overflow-y: auto;
        }
        footer {
            background-color: rgba(30, 30, 30, 0.98);
            color: rgba(200, 200, 200, 0.7);
            font-size: 0.9rem;
            padding: 2rem 1rem;
            text-align: center;
            border-top: 1px solid #444;
            margin-top: auto;
        }
        footer a {
            text-decoration: none;
            color: rgba(200, 200, 200, 0.7);
            margin: 0 10px;
        }
        footer a:hover {
            text-decoration: underline;
        }
        select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-color: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 1rem;
            color: #111827;
            font-family: 'Montserrat', sans-serif;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background-image: url("data:image/svg+xml;utf8,<svg fill='gray' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px 16px;
            padding-right: 40px; /* 화살표 공간 확보 */
        }
        select:hover {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }
        select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3);
        }
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-wrapper {
            display: contents;
        }
        .modal {
            background: #fff;
            border-radius: 12px;
            padding: 24px 32px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: row;
            gap: 16px;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 8px;
        }
        .modal-buttons button {
            flex: 1;
            max-width: 120px;
            padding: 0.6rem 0;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .modal-buttons #confirm,
        .modal-buttons #changePwBtn {
            background-color: #2563eb;
            color: #fff;
        }
        .modal-buttons #close-btn,
        .modal-buttons #cancelChange {
            background-color: #e0e0e0;
            color: #333;
        }
        .modal-buttons button:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }
        .modal-buttons button:active {
            transform: translateY(1px);
        }

        .modal input[type='password'] {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .hidden {
            display: none;
        }
        body.modal-open {
            overflow: hidden;
        }
        #semesterList {
            list-style: none;
            padding-left: 0;
            margin: 12px 0 0 0;
        }
        #semesterList li {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #semesterList .semester-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 10px 14px;
            background: #fff;
            transition: background-color 0.15s ease, box-shadow 0.15s ease,
            border-color 0.15s ease;
            cursor: pointer;
            width: 80%;
        }
        #semesterList .semester-item:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
        }
        #semesterList .semester-name {
            color: #111827;
            text-decoration: none;
            font-weight: 600;
        }
        #semesterList .semester-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #semesterList .rep-label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
        #semesterList .del-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .course-tooltip {
            animation: fadeIn 0.12s;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .details-container {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4등분 고정 */
            gap: 10px;
            margin-top: 10px;
        }
        @media (max-width: 420px) {
            .details-container {
                grid-template-columns: repeat(2, 1fr);
            } /* 모바일 2열 \*/
        }
        .detail {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background-color: #fff;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .detail:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.5s ease;
        }
        .detail .label {
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .detail .value {
            font-size: 20px;
            font-weight: 700;
            color: #007bff;
        }
        /* 영구 배치가 들어올 때 살짝 하이라이트 */
        td.commit-flash {
            animation: commitFlash var(--preview-dur) var(--preview-ease) 1;
        }
        @keyframes commitFlash {
            0% {
                box-shadow: 0 0 0 rgba(37, 99, 235, 0);
            }
            50% {
                box-shadow: 0 0 0 6px rgba(37, 99, 235, 0.15);
            }
            100% {
                box-shadow: 0 0 0 rgba(37, 99, 235, 0);
            }
        }

        #scheduleTable .cell[data-period] { position: relative; }


        .preview-overlay {
            position: absolute;
            inset: 0;
            padding: 8px 10px;
            display: block;               /* 글자 레이아웃을 셀과 동일하게 */
            background: var(--preview-color, #a5d8ff);
            box-shadow: inset 0 0 0 2px var(--preview-color, #a5d8ff);
            border-radius: 6px;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.98);
            transition: opacity 0.18s ease, transform 0.18s ease;
        }

        /* 등장 애니메이션 유지 */
        .preview-overlay.show {
            opacity: 1;
            transform: scale(1);
        }

        .box .desc-list {
            margin: 8px 0 14px;
        }
        .box .desc-list div {
            display: flex;
            gap: 10px;
            padding: 6px 0;
            border-bottom: 1px dashed #e2e8f0;
        }
        .box .desc-list dt {
            width: 66px;
            color: #6b7280;
            font-weight: 700;
        }
        .box .desc-list dd {
            margin: 0;
        }
        /* 테크트리 카드 안의 '모든 테크트리를 만나보세요!'만 작게 */
        .box2 .subtext,
        .box3 .subtext {
            font-size: 0.85rem; /* 필요하면 0.8\~0.95rem 사이로 조절 */
            line-height: 1.4;
            color: #6b7280; /* (선택) 살짝 톤 다운 */
            margin-top: 4px; /* (선택) 위 여백 약간 줄임 \*/
        }
        :root{
            --line:#e2e8f0;
            --muted:#6b7280;
            --brand:#2563eb;
            --brand-weak:#e6efff;
            --danger:#ef4444;
            --shadow:0 6px 18px rgba(2,6,23,.06);
            --preview-color: #a5d8ff; /* ← 원하는 미리보기 고정색으로 변경 */
        }
        .schedule-card{
            border:1px solid var(--line); border-radius:14px; overflow:hidden; background:#fff;
            box-shadow:var(--shadow);
        }
        .schedule-header{
            display:grid; grid-template-columns:120px repeat(5,1fr);
            background:#f9fbff; border-bottom:1px solid var(--line);
        }
        .schedule-header>div{ padding:12px; font-weight:700; text-align:center; }
        .schedule-body{ display:flex; flex-direction:column; }
        .row{
            display:grid; grid-template-columns:120px repeat(5,1fr);
            border-bottom:1px solid var(--line);
        }
        .row:last-child{ border-bottom:none; }
        .time-col{
            padding:12px; background:#fbfbfb; border-right:1px solid var(--line);
            font-weight:700; font-size:13px; text-align:center;
        }
        .time-col span{ display:block; color:var(--muted); font-weight:600; }
        .cell{
            min-height:60px; border-right:1px solid var(--line);
            background:linear-gradient(180deg,#fff 0%,#fff 60%,#fcfcfc 100%);
        }
        .row .cell:last-child{ border-right:none; }
        .cell.busy,
        .course-block.busy {
            /* JS에서 이 변수만 넣어주면 됩니다 */
            --c: var(--course-color, #a5d8ff);

            /* 테두리는 같은 색상 계열로 더 또렷하게 */
            --stroke: color-mix(in oklab, var(--c) 85%, black);

            /* 중앙→바깥으로 갈수록 '흰색에 가까운 틴트'가 이어지도록,
               끝까지 원색 100%로 가지 않고 70~75% 틴트까지만 사용 */
            background:
                    radial-gradient(
                            circle at 50% 45%,
                            #ffffff 0%,
                            color-mix(in oklab, #ffffff 92%, var(--c)) 28%,
                            color-mix(in oklab, #ffffff 88%, var(--c)) 48%,
                            color-mix(in oklab, #ffffff 82%, var(--c)) 68%,
                            color-mix(in oklab, #ffffff 75%, var(--c)) 100%
                    );

            border: 2px solid var(--stroke);
            border-radius: 10px;

            /* 살짝 입체감 */
            box-shadow:
                    inset 0 1px 0 rgba(255,255,255,0.7),
                    0 3px 10px rgba(0,0,0,0.08);

            /* 가운데가 밝으니 진한 텍스트가 가독성 좋음 */
            color: #0f172a;
        }


        @media (max-width:560px){
            .schedule-header,.row{ grid-template-columns:80px repeat(5,1fr); }
            .time-col{ font-size:12px; }
        }
        /* === 시간표 셀 안 텍스트 공통 === */
        /* 과목 블록 전체 */
        .cell {
            position: relative;
            padding: 8px 10px;           /* 셀 안쪽 여백 조금 넉넉하게 */
            overflow: hidden;            /* 넘치면 잘라냄 */
            box-sizing: border-box;
        }

        .cell .slot {
            display: flex;
            flex-direction: column;
            justify-content: center;     /* 세로 중앙 정렬 → 위로 붙이고 싶으면 flex-start */
            height: 100%;
            line-height: 1.3;            /* 줄 간격 약간 넓힘 */
            text-align: center;          /* 가로 정렬: center / left / right */
        }

        /* 과목명 */
        .cell .slot-title {
            font-size: 13px;             /* 기본 0.95rem → 13px */
            font-weight: 800;            /* 더 두껍게 */
            color: #0f172a;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 강의실/교수 */
        .cell .slot-room {
            margin-top: 2px;
            font-size: 12px;             /* 기존보다 조금 작게 */
            font-weight: 600;
            color: var(--muted, #6b7280); /* var(--muted) 우선, 없으면 회색 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0.9;
        }
        /* ====== Grid-row span 기반 시간표 바디 ====== */
        .schedule-grid {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr); /* 시간열 + 월~금 */
            grid-auto-rows: 60px;                        /* 교시 높이 */
            grid-auto-flow: row dense;/* 위치 고정 보조 */
            position: relative;                          /* 코스 블록 배치 기준 */
            background: #fff;
            border-top: 1px solid var(--line);
            border-left: 1px solid var(--line);
        }

        /* 왼쪽 시간 표시 셀 */
        .time-cell {
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            font-weight:700;
            font-size:13px;
            background:#fbfbfb;
            border-bottom: 1px solid var(--line);
            border-right: 1px solid var(--line);
        }
        .time-cell span { color: var(--muted); font-weight:600; }

        /* 빈 자리(격자선 용) */
        .cell-placeholder {
            border-right:1px solid var(--line);
            border-bottom:1px solid var(--line);
            position: relative;
        }

        /* 실제 ‘하나로 합쳐진’ 과목 박스 */
        .course-block {
            border-radius: 10px;
            border: 2px solid rgba(0,0,0,.12);
            box-shadow: inset 0 1px 0 rgba(255,255,255,.7), 0 3px 10px rgba(0,0,0,.08);
            color: #0f172a;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 10px;
            text-align: center;
            overflow: hidden;
        }

        /* 블록 내부 텍스트(기존 템플릿과 톤 맞춤) */
        .course-block .slot{ line-height:1.3; }
        .course-block .slot-title{
            font-size:13px; font-weight:800;
            white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
        }
        .course-block .slot-room{ margin-top:2px; font-size:12px; font-weight:600; opacity:.9; color: var(--muted); }
        /* 미리보기 merged block (연강 1박스) */
        .preview-block {
            border-radius: 10px;
            border: 2px dashed rgba(0,0,0,.18);
            background: var(--preview-color, rgba(99,179,237,0.25));
            color: #0f172a;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 10px;
            text-align: center;
            pointer-events: none;     /* 클릭 막기 */
            z-index: 9;
        }
    </style>
</head>
<body>
<header>
    <h1><a href="/">SMULET</a></h1>
    <nav>
        <a href="#"><b>이용안내</b></a>
        <a href="/login_page" id="loginLink"><b>로그인</b></a>
        <a href="/Register" id="registerLink"><b>회원가입</b></a>
        <a href="/" id="logoutLink" style="display: none"><b>로그아웃</b></a>
        <a href="/" id="" style="display: none"><b>마이페이지</b></a>
    </nav>
</header>
<main>
    <div class="container">
        <!-- 좌측: 대표 시간표 -->
        <div class="representative-container">
            <div class="box representative-box">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 id="representativeTitle" class="card-title">
                        <span class="icon">📌</span> 대표 시간표
                    </h2>
                </div>
                <div id="representativeScheduleContainer">
                    <div class="schedule-card" id="repGridCard">
                        <div class="schedule-header">
                            <div class="time-col"></div>
                            <div>월</div><div>화</div><div>수</div><div>목</div><div>금</div>
                        </div>
                        <div class="schedule-body" id="repGridBody"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <!-- BOX1 -->
            <div class="box box1">
                <h2 class="card-title"><span class="icon">📅</span> 시간표</h2>
                <p class="subtext">시간표를 만나보세요!</p>

                <!-- 드롭다운만으로 바로 학기 추가 -->
                <div style="margin-top: 1px">
                    <select id="semesterSelectInline" style="min-width: 220px">
                        <option value="">학기를 선택해 추가</option>
                        <!-- JS에서 옵션 채워짐 -->
                    </select>
                </div>

                <ul id="semesterList" style="margin-top: 12px"></ul>
                <!-- 시간표 모달 -->
            </div>

            <div
                    id="modalOverlay"
                    class="modal-overlay hidden"
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="pwTitle"
            >
                <div class="modal-wrapper">
                    <div class="modal">
                        <p>비밀번호를 입력하세요</p>
                        <input type="password" id="pw" />
                        <div class="modal-buttons">
                            <button id="confirm" type="button">확인</button>
                            <button id="close-btn" type="button">닫기</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="changePwModal" class="modal-overlay hidden">
                <div class="modal-wrapper">
                    <div class="modal">
                        <p>새 비밀번호를 입력하세요</p>
                        <input
                                type="password"
                                id="newPassword"
                                placeholder="새 비밀번호"
                        />
                        <input
                                type="password"
                                id="confirmPassword"
                                placeholder="비밀번호 확인"
                        />
                        <div class="modal-buttons">
                            <button id="changePwBtn" type="button">변경</button>
                            <button id="cancelChange" type="button">취소</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- BOX2 -->
            <div class="box box2">
                <h2 class="card-title"><span class="icon">🌳</span> 테크트리</h2>
                <p class="subtext">모든 테크트리를 만나보세요!</p>

                <select
                        id="techTreeSelect"
                        onchange="goToTechTree()"
                        style="margin-top: 1px"
                >
                    <option value="">학번을 선택하세요</option>
                    <option value="21">21학번 테크트리</option>
                    <option value="22">22학번 테크트리</option>
                    <option value="23">23학번 테크트리</option>
                    <option value="24">24학번 테크트리</option>
                    <option value="25">25학번 테크트리</option>
                </select>

                <!-- 가로 정렬된 박스들 -->
                <div class="details-container">
                    <div class="detail">
                        <span class="label">bsm</span>
                        <span class="value" id="bsmCredit">0</span>
                    </div>
                    <div class="detail">
                        <span class="label">설계</span>
                        <span class="value" id="designCredit">0</span>
                    </div>
                    <div class="detail">
                        <span class="label">전공선택</span>
                        <span class="value" id="majorElectiveCredit">0</span>
                    </div>
                    <div class="detail">
                        <span class="label">전공심화</span>
                        <span class="value" id="majorAdvancedCredit">0</span>
                    </div>
                </div>
            </div>

            <div class="box box3">
                <div class="section">
                    <h2 class="card-title"><span class="icon">👤</span> 내 정보</h2>
                    <dl class="desc-list">
                        <div>
                            <dt>이름</dt>
                            <dd><span id="userName"></span></dd>
                        </div>
                        <div>
                            <dt>이메일</dt>
                            <dd><span id="studentId"></span></dd>
                        </div>
                        <div>
                            <dt>학과</dt>
                            <dd><span id="userMajor">컴퓨터과학과</span></dd>
                        </div>
                    </dl>
                    <div class="section">
                        <div class="section-header">
                            <h3>🔒 회원 설정</h3>
                            <div class="actions">
                                <button onclick="modifinguserinfo()">비밀번호 변경</button>
                                <button class="red" onclick="deleteAccount()">
                                    회원탈퇴
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="scheduleModal" class="modal-overlay hidden">
                <div class="modal-wrapper">
                    <div
                            class="modal"
                            style=" display: flex; width: 90vw; max-width: 1000px; max-height: 800px; overflow: hidden; padding: 30px; gap: 20px;">
                        <!-- 왼쪽: 시간표 영역 -->
                        <div style="flex: 2; overflow-y: auto">
                            <div style="text-align: right">
                                <button id="closeScheduleModal" style="background: #ef4444; color: white; border: none; border-radius: 5px;padding: 6px 12px;cursor: pointer;">
                                    닫기
                                </button>
                                <button id="saveSchedule" style=" background: #4466ef; color: white; border: none; border-radius: 5px; padding: 6px 12px;  cursor: pointer;">
                                    저장
                                </button>
                            </div>
                            <h2 style="text-align: center; margin-bottom: 15px" id="modalSemesterTitle"></h2>
                            <div id="scheduleTableContainer">
                                <!-- 동적 시간표 -->
                            </div>
                        </div>
                        <div style=" flex: 1; display: flex; flex-direction: column;border-left: 1px solid #ddd;padding-left: 10px; ">
                            <!-- 🔍 검색창 -->
                            <input type="text" id="searchInput" placeholder="과목명 검색" style=" width: 100%; margin-bottom: 10px; padding: 8px;border: 1px solid #ccc; border-radius: 6px; "
                                   oninput="renderCourseList(currentCourseList)"/>

                            <!-- 📚 수업 리스트 -->
                            <div id="classInfoList" style="flex: 1; overflow-y: auto">
                                <!-- JS로 수업 정보가 들어옵니다 -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</main>

<footer>
    <b>
        <a href="#">Github</a>
        <a href="#">개인정보처리방침</a>
        <a href="#">이용약관</a><br /><br />
        <a href="#">Copyright</a>
    </b>
</footer>

<script>
    /***********************
     * 상수 / 전역 상태
     ***********************/
    const semesterOptions = [
        '2025년 2학기',
        '2025년 1학기',
        '2024년 2학기',
        '2024년 1학기',
        '2023년 2학기',
        '2023년 1학기',
        '2022년 2학기',
        '2022년 1학기',
        '2021년 2학기',
        '2021년 1학기',
    ];

    const pastelPalette = [
        "#A5D8FF", // 스카이 블루
        "#B2F2BB", // 민트 그린
        "#FFD8A8", // 살구
        "#FFC9C9", // 라이트 코랄
        "#D0BFFF", // 라일락
        "#B2E3E8", // 파스텔 틸
        "#FFE69A", // 바닐라 옐로
        "#F4C2D7", // 로즈 핑크
        "#C9E4A7", // 세이지 그린
        "#C7D2FE"  // 페리윙클

    ];

    // === Unique Color Manager (과목별 유일 색상) ===
    const ColorManager = (() => {
        const pool = [...pastelPalette];            // 팔레트 복사
        // Fisher–Yates shuffle
        for (let i = pool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        const map = new Map(); // courseKey -> color
        let cursor = 0;

        function nextPoolColor(usedSet) {
            // 아직 안 쓴 색을 하나 반환
            for (let i = 0; i < pool.length; i++) {
                const idx = (cursor + i) % pool.length;
                const c = pool[idx];
                if (!usedSet.has(c)) {
                    cursor = (idx + 1) % pool.length;
                    return c;
                }
            }
            return null; // 다 썼으면 null
        }

        function hslFromString(s) {
            // 팔레트 초과 시에도 충돌 적게끔 고운 파스텔 HSL
            let hash = 0;
            for (const ch of String(s)) {
                hash = ((hash << 5) - hash) + ch.charCodeAt(0);
                hash |= 0;
            }
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 85%)`;
        }

        function get(courseKey) {
            if (!courseKey) return pool[0];
            if (map.has(courseKey)) return map.get(courseKey);

            const usedSet = new Set(map.values());
            let color = nextPoolColor(usedSet);
            if (!color) color = hslFromString(courseKey); // 팔레트 다 쓰면 HSL fallback
            map.set(courseKey, color);
            return color;
        }

        function free(courseKey) {
            if (!courseKey) return;
            map.delete(courseKey);
        }

        function has(courseKey) {
            return map.has(courseKey);
        }

        return { get, free, has };
    })();


    let UserId = null;
    let representativeTermCode = null; // "20252" 같은 형식으로 대표 학기 보관

    let selectedSemesters = [];
    let currentCourseList = []; // 모달에 띄운 현재 학기 전체 수업정보

    // 새 구조 핵심
    let timetableIdsBySemester = {}; // { "20252": 123, ... }
    let currentSemesterCode = null; // 현재 모달에서 편집 중인 학기 코드
    let currentTimetableId = null; // 현재 모달의 timetableId

    // 미리보기로 임시 추가한 요소들을 추적
    const previewSession = {
        zeroAdded: false, // 미리보기 중 0교시를 추가했는가
        extendedTo: null, // 미리보기로 확장한 최댓 교시(숫자)
    };

    const PERIOD_SELECTOR = '.cell[data-period], .cell-placeholder[data-period]';

    /***********************
     * 공통 유틸
     ***********************/



    function toSemesterCode(semText) {
        // "2025년 2학기" → "20252"
        const m = String(semText).match(/(\d{4})\D*(1|2)\D*학기?/);
        return m ? `${m[1]}${m[2]}` : semText.replace(/\D/g, ''); // 백업: 숫자만
    }

    // 작은 대기 유틸
    function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    // /userinfo에서 timetables 배열을 보고, term===semesterCode 인 항목 중 가장 최신 timetableId 반환
    async function fetchLatestTimetableIdFromUserInfo(
        semesterCode,
        { tries = 6, baseDelay = 300 } = {}
    ) {
        if (!semesterCode) throw new Error('semesterCode가 필요합니다.');
        const termNum = Number(semesterCode);

        const token = localStorage.getItem('jwtToken');
        const headers = {
            Authorization: `Bearer ${token}`,
            'Cache-Control': 'no-cache',
        };

        for (let i = 0; i < tries; i++) {
            const res = await fetch(`/userinfo?_=${Date.now()}`, {
                headers,
                cache: 'no-store',
                credentials: 'include',
            });

            if (res.ok) {
                const u = await res.json();
                // console.warn('[userinfo]', u); // 필요하면 구조 확인용

                if (Array.isArray(u?.timetables)) {
                    // term이 일치하는 것들만 필터
                    const matches = u.timetables.filter(
                        (t) => Number(t.term) === termNum
                    );
                    if (matches.length) {
                        // 가장 큰 timetableId를 최신으로 간주
                        const tid = matches.reduce((max, t) => {
                            const v = Number(t.timeTableId ?? t.timetableId ?? t.id);
                            return Number.isFinite(v) ? Math.max(max, v) : max;
                        }, 0);
                        if (tid) return tid;
                    }
                }
            }

            // DB 반영 지연 대비 백오프
            await sleep(baseDelay * (i + 1));
        }

        return null;
    }

    //
    // 빈 시간표 생성 → /userinfo로 timetableId 획득
    async function createTimetableOnServer(semesterCode) {
        let token = localStorage.getItem('jwtToken');
        if (!token) {
            alert('로그인이 필요합니다.');
            window.location.href = '/login_page';
            throw new Error('JWT 없음');
        }

        // 서버가 FormData를 받는다고 가정 (JSON이면 아래를 JSON으로 바꿔도 됨)
        const fd = new FormData();
        fd.append('semester', semesterCode);

        const res = await fetch('/addTimetable', {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` }, // FormData일 땐 Content-Type 지정 X
            body: fd,
            credentials: 'include',
        });

        const raw = await res.text();
        if (!res.ok)
            throw new Error(`addTimetable 실패 (${res.status}): ${raw}`);

        // 응답에 이미 id가 있으면 바로 사용
        try {
            const j = JSON.parse(raw);
            const directId =
                j.timeTableId ??
                j.timetableId ??
                j.id ??
                j.data?.timeTableId ??
                j.data?.id ??
                null;
            if (directId) return Number(directId);
        } catch (_) {
            /* ignore */
        }

        // 없으면 /userinfo에서 term 기준으로 찾아오기 (폴링)
        const tid = await fetchLatestTimetableIdFromUserInfo(semesterCode, {
            tries: 8,
            baseDelay: 250,
        });
        if (!tid)
            throw new Error('userinfo에서 timetableId를 찾지 못했습니다.');
        return tid;
    }

    /***********************
     * 초기 바인딩
     ***********************/
    document.addEventListener('DOMContentLoaded', async function () {
        const loginLink = document.getElementById('loginLink');
        const logoutLink = document.getElementById('logoutLink');
        const registerLink = document.querySelector('nav a[href="/Register"]');
        const token = localStorage.getItem('jwtToken');

        if (token) {
            loginLink.style.display = 'none';
            logoutLink.style.display = 'inline';
            registerLink.style.display = 'none';
        } else {
            loginLink.style.display = 'inline';
            logoutLink.style.display = 'none';
            registerLink.style.display = 'inline';
        }

        logoutLink.addEventListener('click', function (e) {
            e.preventDefault();
            localStorage.removeItem('jwtToken');
            alert('로그아웃 되었습니다.');
            window.location.href = '/';
        });
        /*
        const showSemesterBtn = document.getElementById('showSemesterBtn');
        if (showSemesterBtn) {
          showSemesterBtn.addEventListener('click', showAddSemester);
        }
        */
        /*
        // ✅ 추가: 대표 시간표 갱신 & 학기 리스트 복원
        if (token) {
          loadRepresentativeScheduleOnInit().catch(console.error);
          await hydrateSemestersFromServer();
        }
     */
        // 드롭다운 채우기 & 체인지 바인딩
        populateSemesterSelectInline();
        document
            .getElementById('semesterSelectInline')
            ?.addEventListener('change', onSemesterSelectInlineChange);

        if (token) {
            // 1) userInfo 먼저 확보(→ UserId 세팅 보장)
            await loaduserinfo().catch(console.error);
            // 2) 학기 리스트 복원
            await hydrateSemestersFromServer();

            // DOMContentLoaded 내부에서, token 처리 뒤에 추가:
            await renderRepresentativeFromServer();
        }
    });

    /** 드롭다운 옵션을 갱신한다. (이미 추가된 학기는 제외) */
    function populateSemesterSelectInline() {
        const select = document.getElementById('semesterSelectInline');
        if (!select) return;

        // 현재 값 보존
        const prev = select.value;

        // 옵션 초기화
        select.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '학기를 선택해 추가';
        select.appendChild(placeholder);

        // 아직 추가하지 않은 학기만 채우기
        semesterOptions.forEach((sem) => {
            if (!selectedSemesters.includes(sem)) {
                const opt = document.createElement('option');
                opt.value = sem;
                opt.textContent = sem;
                select.appendChild(opt);
            }
        });

        // 보존하려던 값이 유효하면 유지, 아니면 placeholder로
        if ([...select.options].some((o) => o.value === prev)) {
            select.value = prev;
        } else {
            select.value = '';
        }
    }

    /** 드롭다운에서 학기를 선택하면 즉시 서버에 시간표를 만들고 리스트에 반영 */
    async function onSemesterSelectInlineChange(e) {
        const semText = e.target.value;
        if (!semText) return; // placeholder 선택

        const semesterCode = toSemesterCode(semText);
        try {
            // 1) 서버에 빈 시간표 생성
            const tid = await createTimetableOnServer(semesterCode);

            // 2) 로컬 상태 반영
            timetableIdsBySemester[semesterCode] = tid;
            if (!selectedSemesters.includes(semText)) {
                selectedSemesters.push(semText);
            }

            // 3) UI 갱신
            renderSemesterList();
            populateSemesterSelectInline(); // 방금 추가한 학기는 드롭다운에서 제거
            e.target.value = ''; // 다시 placeholder로
        } catch (err) {
            console.error(err);
            alert(`시간표 생성 중 오류: ${err.message}`);
        }
    }

    /***********************
     * 사용자/계정 관련
     ***********************/
    function loaduserinfo() {
        const token = localStorage.getItem('jwtToken');
        return fetch('/userinfo', {
            method: 'GET',
            headers: { Authorization: `Bearer ${token}` },
        })
            .then((res) => {
                if (!res.ok) throw new Error('사용자 정보 불러오기 실패');
                return res.json();
            })
            .then((data) => {
                document.getElementById('userName').textContent = data.name;
                document.getElementById('studentId').textContent = data.email;
                /*
                                // userId 제대로 저장하기
                                if (data.timetables && data.timetables.length > 0) {
                                  UserId = data.timetables[0].userId;
                                } else {
                                  console.warn("userinfo에 timetables 데이터가 없음:", data);
                                }

                   */
                // 다양한 응답 형태 방어적으로 처리
                UserId =
                    data.userId ?? data.id ?? data.timetables?.[0]?.userId ?? null;
                if (!UserId) console.warn('userId를 찾지 못했습니다.', data);
            })

            .catch((err) => {
                console.error(err);
                alert('사용자 정보를 불러오는데 실패했습니다.');
            });
    }

    function deleteAccount() {
        const token = localStorage.getItem('jwtToken');
        if (
            !confirm(
                '정말로 회원 탈퇴하시겠습니까? 이 작업은 되돌릴 수 없습니다.'
            )
        )
            return;

        fetch('/member/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
            },
        })
            .then((res) => {
                if (!res.ok) throw new Error('서버 응답 오류');
                return res.json();
            })
            .then((data) => {
                if (data.deleteStatus === 'success') {
                    alert('회원 탈퇴가 완료되었습니다.');
                    localStorage.removeItem('jwtToken');
                    window.location.href = '/';
                }
            })
            .catch((err) => {
                alert('회원 탈퇴 중 오류가 발생했습니다.');
                console.error(err);
            });
    }

    function modifinguserinfo() {
        const modalOverlay = document.getElementById('modalOverlay');
        const closeBtn = document.getElementById('close-btn');
        const confirmBtn = document.getElementById('confirm');
        const token = localStorage.getItem('jwtToken');

        modalOverlay.classList.remove('hidden');
        document.body.classList.add('modal-open');

        closeBtn.onclick = () => {
            modalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-open');
        };

        confirmBtn.onclick = () => {
            const pw = document.getElementById('pw').value;

            fetch('/check_pw_button', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`,
                },
                body: JSON.stringify({ pw }),
            })
                .then((res) => {
                    if (!res.ok) throw new Error('서버 응답 오류');
                    return res.json();
                })
                .then((data) => {
                    if (data.Password === true) {
                        alert('비밀번호 확인 완료!');
                        modalOverlay.classList.add('hidden');
                        document
                            .getElementById('changePwModal')
                            .classList.remove('hidden');
                    } else {
                        alert('비밀번호가 일치하지 않습니다.');
                    }
                })
                .catch((err) => {
                    alert('요청 중 문제가 발생했습니다: ' + err.message);
                    console.error(err);
                });
        };
    }

    document.getElementById('changePwBtn').onclick = function () {
        const newPw = document.getElementById('newPassword').value;
        const confirmPw = document.getElementById('confirmPassword').value;
        const token = localStorage.getItem('jwtToken');

        if (!newPw || !confirmPw || newPw !== confirmPw) {
            alert('비밀번호를 정확히 입력해주세요.');
            return;
        }

        fetch('/PWupdate_button', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({ pw: newPw }),
        })
            .then(async (res) => {
                if (!res.ok) {
                    const errorText = await res.text();
                    alert(`서버 오류 ${res.status}: ${errorText}`);
                    throw new Error('서버 오류: ' + res.status);
                }
                return res.json();
            })
            .then((data) => {
                if (data.updateStatus === true) {
                    alert('비밀번호가 성공적으로 변경되었습니다.');
                    document.getElementById('changePwModal').classList.add('hidden');
                } else {
                    alert('비밀번호 변경에 실패했습니다.');
                }
            })
            .catch((err) => {
                alert('비밀번호 변경 중 오류 발생: ' + err.message);
            });
    };
    document
        .getElementById('openPwModalBtn')
        ?.addEventListener('click', () => {
            document.getElementById('changePwModal').classList.remove('hidden');
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmPassword').value = '';
        });
    document.getElementById('close-btn').onclick = function () {
        document.getElementById('modalOverlay').classList.add('hidden');
    };
    document.getElementById('cancelChange').onclick = function () {
        document.getElementById('changePwModal').classList.add('hidden');
    };

    function goToTechTree() {
        const select = document.getElementById('techTreeSelect');
        const year = select.value;
        const token = localStorage.getItem('jwtToken');

        if (!token) {
            alert('로그인 토큰이 없습니다.');
            return;
        }
        if (!year) {
            alert('학번을 선택하세요.');
            return;
        }

        fetch(`/tech_tree?year=${year}`, {
            method: 'GET',
            headers: { Authorization: `Bearer ${token}` },
        })
            .then((res) => {
                if (res.ok) return res.text();
                else throw new Error('Unauthorized');
            })
            .then((html) => {
                document.open();
                document.write(html);
                document.close();
            })
            .catch((err) => {
                console.error(err);
                window.location.href = '/';
            });
    }

    function renderSemesterList() {
        const list = document.getElementById('semesterList');
        list.innerHTML = '';

        selectedSemesters.forEach((sem) => {
            const termCode = toSemesterCode(sem);
            const tid = timetableIdsBySemester[termCode];

            // li 자체를 카드로 만들기
            const li = document.createElement('li');
            li.className = 'semester-item';
            // 카드 전체 클릭 시 모달 오픈
            li.addEventListener('click', () => openScheduleModal(sem));

            // 왼쪽: 학기명 (검정/밑줄없음)
            const nameSpan = document.createElement('span');
            nameSpan.className = 'semester-name';
            nameSpan.textContent = sem;

            // 오른쪽: 액션들(삭제 + 대표 체크)
            const actions = document.createElement('div');
            actions.className = 'semester-actions';

            // 삭제 버튼 (SVG 아이콘)
            const delBtn = document.createElement('button');
            delBtn.className = 'del-btn';
            delBtn.title = '삭제';
            delBtn.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg"
           width="18" height="18" viewBox="0 0 24 24" fill="none"
           stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6l-2 14H7L5 6"></path>
        <path d="M10 11v6"></path>
        <path d="M14 11v6"></path>
      </svg>
    `;
            // 카드 전체 클릭과 구분(버튼 클릭 시 버블 중단)
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeSemester(termCode, tid);
            });

            // 대표 체크박스
            const label = document.createElement('label');
            label.className = 'rep-label';
            // 카드 전체 클릭과 구분
            label.addEventListener('click', (e) => e.stopPropagation());

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = termCode === representativeTermCode; // 대표면 체크
            // 체크박스 크기 키우고 싶으면 아래 두 줄 사용 (원하면 값 조절)
            cb.style.transform = 'scale(1.3)';
            cb.style.margin = '2px';

            cb.onchange = (e) =>
                onToggleRepresentative(termCode, e.target.checked);

            const labTxt = document.createElement('span');
            labTxt.textContent = '대표';

            label.appendChild(cb);
            label.appendChild(labTxt);

            actions.appendChild(delBtn);
            actions.appendChild(label);

            li.appendChild(nameSpan);
            li.appendChild(actions);
            list.appendChild(li);
        });
    }

    function openScheduleModal(semester) {
        const modal = document.getElementById('scheduleModal');
        const title = document.getElementById('modalSemesterTitle');
        const container = document.getElementById('scheduleTableContainer');
        const listContainer = document.getElementById('classInfoList');

        // 현재 학기코드/ID 확보
        currentSemesterCode = toSemesterCode(semester);
        currentTimetableId =
            timetableIdsBySemester[currentSemesterCode] ?? null;

        if (!currentTimetableId) {
            alert(
                '이 학기의 시간표 ID가 없습니다. 먼저 "시간표 추가"에서 학기를 추가하세요.'
            );
            return;
        }

        document.getElementById('closeScheduleModal').onclick = function () {
            document.getElementById('scheduleModal').classList.add('hidden');
            document.body.classList.remove('modal-open');
            hideCourseTooltip();
        };

        title.textContent = semester;
        // ✅ 교체 (모달 열 때 표 생성)
        container.innerHTML = generateModalGridSpanTable();


        const modalGrid = document.getElementById('modalGridSpanBody');

        if (modalGrid) {
            modalGrid.style.display = 'grid';            // 혹시 모를 상위 스타일 무력화
            modalGrid.style.gridAutoFlow = 'row dense';  // 위→아래, 빈칸 메우기
            modalGrid.style.alignContent = 'start';      // 컨텐츠를 상단부터 채우기
            modalGrid.style.justifyContent = 'stretch';  // 가로는 꽉 채우기
            modalGrid.style.gridAutoRows = '52px';       // 각 행 고정 높이(원하는 값으로)
        }
        if (modalGrid && !modalGrid.__previewClearBound) {
            modalGrid.addEventListener('click', () => {
                // 🔹 빈 공간/셀/블록 어디든 클릭하면 프리뷰만 지움(영구 블록은 유지)
                removePreviewFromSchedule();
            });
            modalGrid.__previewClearBound = true; // 중복 바인딩 방지 플래그
        }


        listContainer.innerHTML = '<p>수업 정보를 불러오는 중입니다...</p>';
        modal.classList.remove('hidden');
        document.body.classList.add('modal-open');

        const token = localStorage.getItem('jwtToken');

        console.log('👉 timetableId:', currentTimetableId);
        console.log('👉 userId:', UserId);

        // 🟢 1) 현재 시간표 불러오기  (교체 버전)
        fetch('/getTC', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify(UserId),
        })
            .then((res) => {
                if (!res.ok) throw new Error('시간표 조회 실패');
                return res.json();
            })
            .then(async (allRows) => {
                // 현재 모달의 timetableId에 해당하는 항목만
                const filtered = (allRows || []).filter((r) => {
                    const tid = getTid(r);
                    return Number.isFinite(tid) && tid === Number(currentTimetableId);
                });

                // ⬇ 과목 ID만 추출 (문자열/숫자 모두 허용)
                const courseIds = Array.from(
                    new Set(
                        filtered
                            .map(getCourseId)
                            .filter((v) => v != null && String(v).trim() !== '')
                    )
                );
                if (courseIds.length === 0) {
                    // 저장된 수업이 없으면 초기화 상태 그대로
                    return;
                }

                // ⬇ 대표 시간표와 동일하게, 슬롯 API로 변환된 데이터 받아 렌더
                const slotRes = await fetch('/getTS2TE', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify({ getScheduleIds: courseIds }),
                });
                if (!slotRes.ok) throw new Error('슬롯 조회 실패');
                const slotData = await slotRes.json(); // 필드: time_start, time_end, day, identify_number_of_course, ...
                renderScheduleFromTS2TE(slotData); // ⬅ 아래 새 함수
            })
            .catch((err) => console.error('getTC/슬롯 로드 오류:', err));

        // 🟢 2) 수업 목록 불러오기
        fetch('/a', { headers: { Authorization: `Bearer ${token}` } })
            .then((res) => res.json())
            .then((data) => {
                currentCourseList = data;
                console.log(data);
                renderCourseList(data);
                attachCellEvents();
            })
            .catch((err) => {
                listContainer.innerHTML = `<p style="color:red;">수업 목록을 불러오지 못했습니다.</p>`;
                console.error(err);
            });

        // 저장 핸들러(중복 방지)
        const saveBtn = document.getElementById('saveSchedule');
        saveBtn.replaceWith(saveBtn.cloneNode(true));
        document
            .getElementById('saveSchedule')
            .addEventListener('click', onClickSaveSchedule);
    }




    // 모달 시간표 렌더링

    function renderScheduleFromTS2TE(scheduleData){
        const grid = document.getElementById('modalGridSpanBody');
        if(!grid || !Array.isArray(scheduleData)) return;

        // 필요한 만큼 행 확장
        let needMax = 9;
        scheduleData.forEach(it => {
            const end = toPeriodNumber(it.time_end ?? it.timeEnd ?? it.periodEnd, null);
            if (end != null) needMax = Math.max(needMax, end);
        });
        ensureModalGridSpanMax(needMax);

        scheduleData.forEach(item => {
            const subject    = item.courseName || '';
            const professor  = item.professorName || '';
            const classroom  = item.classroom || '';
            const courseCode = item.identify_number_of_course ?? item.identifyNumberOfCourse ?? item.courseCode ?? subject;

            const dayIdx = toPeriodNumber(item.day, 0) - 1; // 0..4
            const pStart = toPeriodNumber(item.time_start ?? item.timeStart ?? item.periodStart, null);
            const pEnd   = toPeriodNumber(item.time_end   ?? item.timeEnd   ?? item.periodEnd   ?? pStart, null);
            if (dayIdx < 0 || pStart == null || pEnd == null) return;

            const color = ColorManager.get(courseCode);
            const block = document.createElement('div');
            block.className = 'course-block busy';
            block.style.gridColumn = String(dayIdx + 2);


            const grid = document.getElementById('modalGridSpanBody');
            const startRow = gridRowForPeriod(grid, pStart);
            const endRow   = gridRowForPeriod(grid, pEnd) + 1;
            block.style.gridRow = `${startRow} / ${endRow}`;



            block.style.setProperty('--course-color', color);
            block.dataset.courseId = courseCode;

            const coursePk = item.courseId ?? item.course_id ?? item.id ?? item.coursePK ?? null;
            if (coursePk != null) block.dataset.coursePk = String(coursePk);

            block.innerHTML = renderSlotHTML(subject, classroom, professor);

            // 툴팁
            block.onmouseenter = () => showCourseTooltip(block, {
                courseName: subject, professorName: professor, classroom,
                credit: item.credit ?? '-', majorOrCulture: item.majorOrCulture ?? null,
                scheduleDay: dayIdx + 1, timeStart: pStart, timeEnd: pEnd,
                identifyNumberOfCourse: courseCode
            });
            block.onmouseleave = hideCourseTooltip;

            grid.appendChild(block);

            // 저장/충돌 체크를 위해 placeholder에 점유마킹
            for (let p = pStart; p <= pEnd; p++) {
                const ph = grid.querySelector(`.cell-placeholder[data-day="${dayIdx}"][data-period="${p}"]`);
                if (ph) {
                    ph.setAttribute('data-course-id', courseCode);
                    if (coursePk != null) ph.setAttribute('data-course-pk', String(coursePk));
                    ph.style.borderBottom = 'none'; // 블록 아래 가로줄 감춤
                }
            }
        });

        attachCellEvents(); // 블록에도 툴팁 연결
    }



    function renderCourseList(classList) {
        const listContainer = document.getElementById('classInfoList');
        listContainer.innerHTML = '';

        const searchInput = document.getElementById('searchInput');
        const searchTerm = searchInput?.value?.toLowerCase() || '';

        if (!Array.isArray(classList) || classList.length === 0) {
            listContainer.innerHTML = '<p>수업 정보가 없습니다.</p>';
            return;
        }

        const groupedByCourse = groupByCourse(classList);

        Object.entries(groupedByCourse).forEach(([courseName, allEntries]) => {
            if (searchTerm && !courseName.toLowerCase().includes(searchTerm))
                return;

            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = '12px';
            wrapper.style.border = '1px solid #ccc';
            wrapper.style.borderRadius = '6px';
            wrapper.style.background = '#f9f9f9';
            wrapper.style.padding = '10px';

            const header = document.createElement('div');
            header.style.cursor = 'pointer';
            header.style.fontWeight = 'bold';
            header.style.color = '#2563eb';
            header.textContent = courseName;

            const subList = document.createElement('div');
            subList.style.display = 'none';
            subList.style.marginTop = '8px';

            const groupedByIdentifyNumber = {};
            allEntries.forEach((entry) => {
                const key = entry.identifyNumberOfCourse;
                if (!groupedByIdentifyNumber[key])
                    groupedByIdentifyNumber[key] = [];
                groupedByIdentifyNumber[key].push(entry);
            });

            Object.values(groupedByIdentifyNumber).forEach((entries) => {
                const detail = document.createElement('div');
                detail.style.padding = '6px 10px';
                detail.style.borderTop = '1px solid #ddd';
                detail.style.cursor = 'pointer';
                detail.style.background = '#fff';

                const professor = entries[0].professorName || '-';
                const code = entries[0]?.identifyNumberOfCourse ?? '';
                const division = (typeof code === 'string' && code.includes('-'))
                    ? code.split('-')[1]
                    : '?';

                const weekdayNames = ['월', '화', '수', '목', '금'];
                const timeText = entries
                    .map((e) => {
                        const day =
                            weekdayNames[e.scheduleDay - 1] || `요일 ${e.scheduleDay}`;
                        return e.timeStart === e.timeEnd
                            ? `${day} ${e.timeStart}교시`
                            : `${day} ${e.timeStart}~${e.timeEnd}교시`;
                    })
                    .join(', ');

                detail.innerHTML = `
          분반: ${division}<br>
          교수: ${professor}<br>
          시간: ${timeText}
        `;

                detail.addEventListener('mouseover', () => {
                    if (!isCoursePermanentlyAdded(entries))
                        previewCourseOnSchedule(entries);
                });
                detail.addEventListener('mouseout', () => {
                    if (!isCoursePermanentlyAdded(entries))
                        removePreviewFromSchedule();
                });
                detail.addEventListener('click', () => {
                    addCourseToScheduleTable(entries); // 실제 등록/토글
                });

                subList.appendChild(detail);
            });

            header.addEventListener('click', () => {
                subList.style.display =
                    subList.style.display === 'none' ? 'block' : 'none';
            });

            wrapper.appendChild(header);
            wrapper.appendChild(subList);
            listContainer.appendChild(wrapper);
        });
    }

    function groupByCourse(data) {
        const map = {};
        data.forEach((entry) => {
            const key = entry.courseName;
            if (!map[key]) map[key] = [];
            map[key].push(entry);
        });
        return map;
    }



    // ★ 파일 상단(상수 모음 근처)에 추가: 원하는 고정 미리보기 색
    const FIXED_PREVIEW_COLOR = 'rgba(99, 179, 237, 0.25)'; // <- 네가 원하는 색으로 변경

    function previewCourseOnSchedule(courseEntries) {
        // ⬇ 그리드 기반 모달이면 그쪽 전용 프리뷰 사용
        if (document.getElementById('modalGridSpanBody')) {
            return previewCourseOnGrid(courseEntries);
        }

        // ↓↓↓ 여기부터는 네가 이미 갖고 있던 "테이블 방식" 미리보기 로직 (그대로 유지) ↓↓↓
        const table = document.getElementById('scheduleTable');
        if (!table) return;

        const needsZero = courseEntries.some(
            (e) => Number(e.timeStart) === 0 || Number(e.timeEnd) === 0
        );
        if (needsZero && !hasZeroPeriod(table)) {
            prependZeroPeriodRow(table);
            previewSession.zeroAdded = true;
        }

        let neededMax = 9;
        courseEntries.forEach((e) => {
            neededMax = Math.max(neededMax, Number(e.timeEnd));
        });
        const beforeMax = getCurrentMaxPeriod(table);
        if (neededMax > beforeMax) {
            ensureTableMaxPeriod(table, neededMax);
            previewSession.extendedTo = neededMax;
        }

        courseEntries.forEach((entry) => {
            const dayIndex = entry.scheduleDay - 1;
            for (let p = entry.timeStart; p <= entry.timeEnd; p++) {
                const cell = getCell(table, dayIndex, p);
                if (!cell) continue;
                let overlay = cell.querySelector('.preview-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'preview-overlay';
                    cell.appendChild(overlay);
                }
                overlay.innerHTML = renderSlotHTML(entry.courseName, entry.classroom, entry.professorName || '');
                overlay.style.setProperty('--preview-color', FIXED_PREVIEW_COLOR);
                requestAnimationFrame(() => overlay.classList.add('show'));
                cell.setAttribute('data-preview', 'true');
            }
        });
    }




    /** 미리보기 해제 (그리드용 포함) — 교체 */
    function removePreviewFromSchedule() {
        const grid = document.getElementById('modalGridSpanBody');
        if (grid) {
            // 그리드인 경우: 프리뷰 블록만 제거
            grid.querySelectorAll('.preview-block').forEach(b => b.remove());

            // 미리보기 때문에 추가했던 0교시 행 정리
            if (previewSession.zeroAdded) {
                removeZeroPeriodGridIfEmpty(grid);
                previewSession.zeroAdded = false;
            }
            // 아래 확장 원복은 격자선 구조상 자동으로 문제 없음(빈 줄도 placeholder라 유지 OK)
            return;
        }

        // ↓↓↓ (테이블 버전 기존 로직 유지) ↓↓↓
        const table = document.getElementById('scheduleTable');
        if (!table) return;

        table.querySelectorAll('.preview-overlay').forEach((ov) => {
            ov.classList.remove('show');
            ov.addEventListener('transitionend', () => ov.remove(), { once: true });
        });
        table.querySelectorAll('td[data-preview="true"]').forEach((td) => {
            td.removeAttribute('data-preview');
        });

        if (previewSession.extendedTo != null) {
            const permanentMax = getPermanentMaxPeriod(table);
            shrinkTableTo(table, permanentMax);
            previewSession.extendedTo = null;
        }
        if (previewSession.zeroAdded) {
            if (hasZeroPeriod(table) && isZeroRowEmpty(table)) {
                const zeroTr = table.querySelector('td[data-period="0"]')?.parentElement;
                if (zeroTr) zeroTr.remove();
            }
            previewSession.zeroAdded = false;
        }
    }

    // 문자열 "10", "10교시" 등도 안전하게 숫자로
    function toPeriodNumber(v, fallback = null) {
        if (v == null) return fallback;
        if (typeof v === 'number' && Number.isFinite(v)) return v;
        const m = String(v).match(/\d+/);
        if (!m) return fallback;
        const n = parseInt(m[0], 10);
        return Number.isFinite(n) ? n : fallback;
    }

    function isCoursePermanentlyAdded(courseEntries) {
        const table = document.getElementById('scheduleTable');
        if (!table || !courseEntries?.length) return false;

        const courseId = courseEntries[0].identifyNumberOfCourse;

        for (const entry of courseEntries) {
            const dayIndex = toPeriodNumber(entry.scheduleDay, 0) - 1;
            const start = toPeriodNumber(
                entry.timeStart ?? entry.periodStart,
                null
            );
            const end = toPeriodNumber(
                entry.timeEnd ?? entry.periodEnd ?? entry.timeStart,
                null
            );

            if (dayIndex < 0 || start == null || end == null) continue;

            for (let p = start; p <= end; p++) {
                const cell = getCell(table, dayIndex, p); // ← 안전 접근
                if (!cell) continue;
                if (cell.getAttribute('data-course-id') === courseId) {
                    return true;
                }
            }
        }
        return false;
    }

    function addCourseToScheduleTable(entries) {
        const grid = document.getElementById('modalGridSpanBody');
        if (grid) return addCourseToScheduleTableGrid(entries);
        const table = document.getElementById('scheduleTable');
        if (!table || !Array.isArray(entries) || entries.length === 0) return;

        const courseName = entries[0].courseName;
        const classroom  = entries[0].classroom;
        const professor  = entries[0].professorName || '';
        const courseCode = entries[0].identifyNumberOfCourse;
        const coursePk   =
            entries[0].courseId ?? entries[0].course_id ?? entries[0].id ?? entries[0].coursePK ?? null;

        // 이미 배치되어 있나 탐지
        let alreadyPlaced = false;
        outer: for (const e of entries) {
            const d = toPeriodNumber(e.scheduleDay, 0) - 1;
            const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
            const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (d < 0 || s == null || t == null) continue;
            for (let p = s; p <= t; p++) {
                const cell = getCell(table, d, p);
                if (cell && cell.getAttribute('data-course-id') === courseCode) {
                    alreadyPlaced = true;
                    break outer;
                }
            }
        }

        // ===== 토글 제거 =====
        if (alreadyPlaced) {
            for (const e of entries) {
                const d = toPeriodNumber(e.scheduleDay, 0) - 1;
                const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
                const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
                if (d < 0 || s == null || t == null) continue;

                for (let p = s; p <= t; p++) {
                    const cell = getCell(table, d, p);
                    if (!cell || cell.getAttribute('data-course-id') !== courseCode) continue;

                    // 즉시 정리 (배경/오버레이 잔상 방지)
                    cell.innerHTML = '';
                    cell.removeAttribute('data-course-id');
                    cell.removeAttribute('data-course-pk');
                    cell.removeAttribute('data-preview');

                    // 그라데이션/보더를 담당하는 클래스·변수 제거
                    cell.classList.remove('busy');
                    cell.style.removeProperty('--course-color');

                    cell.style.removeProperty('background');
                    cell.style.removeProperty('backgroundImage');
                    cell.style.boxShadow = '';

                    const ov = cell.querySelector('.preview-overlay');
                    if (ov) ov.remove();

                    // 살짝 페이드
                    try {
                        cell.animate(
                            [
                                { opacity: 1,   transform: 'scale(1)'    },
                                { opacity: 0.92, transform: 'scale(0.98)' },
                                { opacity: 1,   transform: 'scale(1)'    },
                            ],
                            { duration: 140, easing: 'ease' }
                        );
                    } catch (_) {}
                }
            }

            // 전부 지워졌으면 컬러 반납
            const colorKey = courseCode || courseName;
            const stillExists = document.querySelector(
                `#scheduleTable .cell[data-course-id="${courseCode}"]`
            );
            if (!stillExists) {
                ColorManager.free(colorKey);
            }

            normalizeTableAfterMutation(table);
            return;
        }

        // ===== 신규 배치 =====

        // 0교시 필요 시 추가
        if (entries.some(e =>
            toPeriodNumber(e.timeStart, null) === 0 || toPeriodNumber(e.timeEnd, null) === 0
        )) {
            if (!table.querySelector('.cell[data-period="0"]')) {
                prependZeroPeriodRow(table);
            }
        }

        // 아래로 확장
        let neededMax = 9;
        for (const e of entries) {
            const end = toPeriodNumber(e.timeEnd ?? e.periodEnd ?? e.timeStart, null);
            if (end != null) neededMax = Math.max(neededMax, end);
        }
        ensureTableMaxPeriod(table, neededMax);

        // 충돌 확인
        for (const e of entries) {
            const d = toPeriodNumber(e.scheduleDay, 0) - 1;
            const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
            const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (d < 0 || s == null || t == null) continue;

            for (let p = s; p <= t; p++) {
                const cell = getCell(table, d, p);
                if (!cell) continue;
                const existing = cell.getAttribute('data-course-id');
                if (existing && existing !== courseCode) {
                    alert('해당 시간에 이미 다른 수업이 있습니다!');
                    return;
                }
            }
        }

        // 배치
        const colorKey = courseCode || courseName;
        const bg = ColorManager.get(colorKey);

        for (const e of entries) {
            const d = toPeriodNumber(e.scheduleDay, 0) - 1;
            const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
            const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (d < 0 || s == null || t == null) continue;

            for (let p = s; p <= t; p++) {
                const cell = getCell(table, d, p);
                if (!cell) continue;

                const wasPreview = cell.getAttribute('data-preview') === 'true';

                cell.innerHTML = renderSlotHTML(courseName, classroom, professor);

                // ▼ gradient 스타일: CSS 변수 + busy 클래스
                cell.style.setProperty('--course-color', bg);
                cell.classList.add('busy');
                cell.style.removeProperty('background');
                cell.style.removeProperty('backgroundImage');

                cell.setAttribute('data-course-id', courseCode);
                if (coursePk != null) cell.setAttribute('data-course-pk', String(coursePk));
                if (wasPreview) cell.removeAttribute('data-preview');

                // 미리보기 오버레이 제거
                const ov = cell.querySelector('.preview-overlay');
                if (ov) ov.remove();

                try {
                    cell.animate(
                        [
                            { opacity: 0.0, transform: 'scale(0.98)' },
                            { opacity: 1,   transform: 'scale(1)'    },
                        ],
                        { duration: 120, easing: 'ease' }
                    );
                } catch (_) {}
            }
        }

        attachCellEvents();
    }
    function addCourseToScheduleTableGrid(entries){
        const grid = document.getElementById('modalGridSpanBody');
        if (!grid || !entries?.length) return;

        removePreviewFromSchedule();

        const courseName = entries[0].courseName;
        const classroom  = entries[0].classroom;
        const professor  = entries[0].professorName || '';
        const courseCode = entries[0].identifyNumberOfCourse;
        const coursePk   = entries[0].courseId ?? entries[0].course_id ?? entries[0].id ?? entries[0].coursePK ?? null;

        // 이미 배치되어 있으면 → 블록/마킹 제거
// 이미 배치되어 있으면 → 블록/마킹 제거
        const existing = grid.querySelectorAll(`.course-block[data-course-id="${courseCode}"]`);
        if (existing.length){
            existing.forEach(b => b.remove());
            grid.querySelectorAll(`.cell-placeholder[data-course-id="${courseCode}"]`).forEach(ph=>{
                ph.removeAttribute('data-course-id');
                ph.removeAttribute('data-course-pk');
                ph.style.borderBottom = '';
            });
            ColorManager.free(courseCode || courseName);

            // 🔻 추가: 0교시가 비었다면 행 제거
            removeZeroPeriodGridIfEmpty(grid);
            return;
        }


        // 충돌 검사
        for (const e of entries){
            const d = toPeriodNumber(e.scheduleDay,0) - 1;
            const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
            const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (d<0 || s==null || t==null) continue;
            for (let p=s; p<=t; p++){
                const ph = grid.querySelector(`.cell-placeholder[data-day="${d}"][data-period="${p}"]`);
                const ex = ph?.getAttribute('data-course-id');
                if (ex && ex !== courseCode){ alert('해당 시간에 이미 다른 수업이 있습니다!'); return; }
            }
        }

        // 행 확장
        let needMax = 9;
        entries.forEach(e=>{
            const end = toPeriodNumber(e.timeEnd ?? e.periodEnd ?? e.timeStart, null);
            if (end != null) needMax = Math.max(needMax, end);
        });
        ensureModalGridSpanMax(needMax);

        // 요일별 구간 합치기 → 블록 배치
        const byDay = {};
        entries.forEach(e=>{
            const d = toPeriodNumber(e.scheduleDay,0) - 1;
            const s = toPeriodNumber(e.timeStart ?? e.periodStart, null);
            const t = toPeriodNumber(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (d<0 || s==null || t==null) return;
            (byDay[d] ||= []).push([s,t]);
        });

        const color = ColorManager.get(courseCode || courseName);

        Object.entries(byDay).forEach(([dStr,ranges])=>{
            const d = Number(dStr);
            ranges.sort((a,b)=>a[0]-b[0]);
            let cur=null, merged=[];
            for (const [s,t] of ranges){
                if (!cur) cur=[s,t];
                else if (s <= cur[1]+1) cur[1] = Math.max(cur[1], t); // 붙어있으면 병합
                else { merged.push(cur); cur=[s,t]; }
            }
            if (cur) merged.push(cur);

            merged.forEach(([s,t])=>{
                const block = document.createElement('div');
                block.className = 'course-block busy';
                block.style.gridColumn = String(d+2);

                // ✅ 교체: 교시→grid-row 변환
                const startRow = gridRowForPeriod(grid, s);
                const endRow   = gridRowForPeriod(grid, t) + 1;
                block.style.gridRow = `${startRow} / ${endRow}`;

                block.style.setProperty('--course-color', color);
                block.dataset.courseId = courseCode;
                if (coursePk != null) block.dataset.coursePk = String(coursePk);
                block.innerHTML = renderSlotHTML(courseName, classroom, professor);
                block.onmouseenter = () => showCourseTooltip(block, {
                    courseName, professorName: professor, classroom,
                    scheduleDay: d+1, timeStart: s, timeEnd: t,
                    identifyNumberOfCourse: courseCode
                });
                block.onmouseleave = hideCourseTooltip;
                grid.appendChild(block);

                // 점유 마킹 (저장/충돌 체크용)
                for (let p=s; p<=t; p++){
                    const ph = grid.querySelector(`.cell-placeholder[data-day="${d}"][data-period="${p}"]`);
                    if (ph){
                        ph.setAttribute('data-course-id', courseCode);
                        if (coursePk != null) ph.setAttribute('data-course-pk', String(coursePk));
                        ph.style.borderBottom = 'none';
                    }
                }
            });
        });
    }


    // ✅ 교체
    function attachCellEvents() {
        const root = document.getElementById('scheduleTable');
        if (!root) return;

        // placeholder / cell (점유마킹 돼 있으면 툴팁)
        root.querySelectorAll('.cell[data-period], .cell-placeholder[data-period]')
            .forEach(cell => {
                cell.onmouseover = () => {
                    const courseId = cell.getAttribute('data-course-id');
                    if (!courseId) return;
                    const info = currentCourseList.find(c => c.identifyNumberOfCourse === courseId);
                    if (info) showCourseTooltip(cell, info);
                };
                cell.onmouseout = hideCourseTooltip;
            });

        // 실제 합쳐진 블록
        root.querySelectorAll('.course-block').forEach(block => {
            const courseId = block.getAttribute('data-course-id');
            const info = currentCourseList.find(c => c.identifyNumberOfCourse === courseId);
            if (info){
                block.onmouseenter = () => showCourseTooltip(block, info);
                block.onmouseleave = hideCourseTooltip;
            }
        });
    }



    function showCourseTooltip(cell, courseInfo) {
        hideCourseTooltip();
        const tooltip = document.createElement('div');
        tooltip.className = 'course-tooltip';
        tooltip.style.position = 'absolute';
        tooltip.style.zIndex = 2000;
        tooltip.style.minWidth = '180px';
        tooltip.style.maxWidth = '260px';
        tooltip.style.background = '#ffffffcc';
        tooltip.style.border = '1px solid #2563eb';
        tooltip.style.borderRadius = '10px';
        tooltip.style.boxShadow = '0 4px 18px rgba(30,80,210,0.13)';
        tooltip.style.padding = '14px 18px 14px 14px';
        tooltip.style.fontSize = '0.98rem';
        tooltip.style.pointerEvents = 'none';
        tooltip.innerHTML = `
      <b>${courseInfo.courseName}</b>
      <br>교수: ${courseInfo.professorName || '-'}
      <br>강의실: ${courseInfo.classroom}
      <br>구분: ${courseInfo.majorOrCulture ? '전공' : '교양'}
      <br>학점: ${courseInfo.credit}
      <br>요일: ${
            ['월', '화', '수', '목', '금'][courseInfo.scheduleDay - 1] ||
            courseInfo.scheduleDay
        }
      <br>교시: ${courseInfo.timeStart} ~ ${courseInfo.timeEnd}
      <br>과목코드: ${courseInfo.identifyNumberOfCourse}
    `;
        document.body.appendChild(tooltip);

        const rect = cell.getBoundingClientRect();
        tooltip.style.left = rect.right + 8 + 'px';
        tooltip.style.top = rect.top + window.scrollY + 'px';
    }

    function hideCourseTooltip() {
        const prev = document.querySelector('.course-tooltip');
        if (prev) prev.remove();
    }

    // ✅ 교체
    function getSelectedClassIds() {
        const root = document.getElementById('scheduleTable') || document;
        const idSet = new Set();

        // 1) 블록/셀에 달린 data-course-pk 우선
        root.querySelectorAll('.course-block[data-course-pk], .cell[data-course-pk], .cell-placeholder[data-course-pk]')
            .forEach(el => {
                const pk = Number(el.getAttribute('data-course-pk'));
                if (Number.isInteger(pk) && pk > 0) idSet.add(pk);
            });

        if (idSet.size) return Array.from(idSet);

        // 2) 코드 기반 fallback (블록/placeholder/셀 모두)
        const codes = new Set();
        root.querySelectorAll('[data-course-id]').forEach(el => {
            const c = el.getAttribute('data-course-id');
            if (c) codes.add(c);
        });

        currentCourseList.forEach(e => {
            const pk = e.courseId ?? e.course_id ?? e.timeTableId ?? e.time_table_id ?? e.id ?? e.coursePK ?? e.pk ?? null;
            const code = e.identifyNumberOfCourse ?? e.identify_number_of_course ?? e.courseCode ?? null;
            const n = Number(pk);
            if (code && codes.has(code) && Number.isInteger(n) && n > 0) idSet.add(n);
        });

        return Array.from(idSet);
    }



    async function onClickSaveSchedule() {
        try {
            // 1) timetableId 확보
            if (!currentTimetableId) {
                currentTimetableId = timetableIdsBySemester[currentSemesterCode] ?? null;
            }
            if (!currentTimetableId) {
                currentTimetableId = await fetchLatestTimetableIdFromUserInfo(currentSemesterCode);
            }
            if (!currentTimetableId) throw new Error('timetableId가 없습니다.');

            // 2) 선택된 과목 PK 수집
            const classIds = getSelectedClassIds();
            if (!Array.isArray(classIds) || classIds.length === 0) {
                alert('저장할 수업이 없습니다.');
                return;
            }

            // 중복/비정상 값 방지
            const courseIds = Array.from(new Set(classIds.map(n => Number(n))))
                .filter(n => Number.isInteger(n) && n > 0);

            const token = localStorage.getItem('jwtToken');
            const payload = {
                timetableId: Number(currentTimetableId),
                courseIds,
            };

            console.log('[addTC] Request payload:', payload);

            // 3) JSON POST
            const res = await fetch('/addTC', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...(token ? { Authorization: `Bearer ${token}` } : {}),
                },
                body: JSON.stringify(payload),
            });

            console.log('[addTC] Response status:', res.status, res.statusText);
            console.log('[addTC] Response headers:', Object.fromEntries(res.headers.entries()));

            // 4) 본문 파싱
            const raw = await res.text();
            let data;
            try { data = raw ? JSON.parse(raw) : null; } catch { data = raw || null; }

            // 5) 에러 처리
            if (!res.ok) {
                let msg = (data && data.message) ? data.message : (typeof data === 'string' ? data : `HTTP ${res.status}`);

                // Duplicate entry 예쁘게 가공
                if (typeof msg === 'string' && msg.includes('Duplicate entry')) {
                    const m = msg.match(/'(\d+)-(\d+)'/); // 'timetableId-courseId'
                    msg = m
                        ? `이미 추가된 과목이 있어요 (timetableId=${m[1]}, courseId=${m[2]}).`
                        : '이미 추가된 과목이 포함되어 있어 저장할 수 없습니다.';
                }

                console.error('[addTC] Failed:', { status: res.status, data });
                throw new Error(msg);
            }

            console.log('[addTC] Success:', data);
            alert('저장 완료!');
            return data; // { Status: "Success" } 예상
        } catch (err) {
            console.error('[addTC] Exception:', err);
            alert(`저장 중 오류: ${err.message}`);
        }
    }

    // 영구 배치된(= data-course-id 존재) 셀이 있는 최댓 교시를 기준으로 표를 정리
    function normalizeTableAfterMutation(table) {
        if (!table) return;

        // 1) 아래쪽 꼬리 행 정리: 영구 수업의 최댓 교시까지만 유지 (최소 9교시)
        const targetMax = getPermanentMaxPeriod(table); // 내부에서 Math.max(9, …) 처리
        shrinkTableTo(table, targetMax);

        // 2) 0교시 행 정리: 0교시에 영구 수업이 하나도 없으면 0교시 행 제거
        if (hasZeroPeriod(table) && isZeroRowEmpty(table)) {
            const zeroTr = table.querySelector(
                'td[data-period="0"]'
            )?.parentElement;
            if (zeroTr) zeroTr.remove();
        }
    }


    // 현재 그리드에 0교시 행이 있는가?
    function hasZeroPeriod(container) {
        return !!(container || document).querySelector('.cell[data-period="0"]');
    }

    // 현재 가진 최댓 교시(미리보기 포함)
    function getCurrentMaxPeriod(container) {
        let max = 1;
        (container || document).querySelectorAll(PERIOD_SELECTOR).forEach(el => {
            const p = Number(el.getAttribute('data-period'));
            if (Number.isFinite(p)) max = Math.max(max, p);
        });
        return max;
    }
    // 저장 대상(= data-course-id 존재) 기준 최댓 교시 (최소 9 유지)
    function getPermanentMaxPeriod(container) {
        let max = 1;
        (container || document).querySelectorAll(PERIOD_SELECTOR).forEach(el => {
            if (el.getAttribute('data-course-id')) {
                const p = Number(el.getAttribute('data-period'));
                if (Number.isFinite(p)) max = Math.max(max, p);
            }
        });
        return Math.max(9, max);
    }

    // 0교시 행이 비었는지(영구 배치 기준)
    function isZeroRowEmpty(container) {
        const zeroCells = (container || document).querySelectorAll('.cell[data-period="0"]');
        if (zeroCells.length === 0) return true;
        for (const c of zeroCells) {
            if (c.getAttribute('data-course-id')) return false;
        }
        return true;
    }


    // 필요한 교시까지 확장
    // ✅ 교체
    function ensureTableMaxPeriod(container, neededMax) {
        const root = (container || document);
        if (root.querySelector('#modalGridSpanBody')) {
            ensureModalGridSpanMax(neededMax);  // ← 모달 grid면 이쪽
            return;
        }
        // ← 기존 행 테이블 확장 로직 그대로 유지
        const tbl = root.querySelector('#scheduleTable') || container || document;
        let curMax = getCurrentMaxPeriod(tbl);
    }

    function getCell(container, dayIdx, period) {
        const root = (container && container.querySelector) ? container : document;
        return root.querySelector(
            `.cell[data-day="${dayIdx}"][data-period="${period}"],` +
            `.cell-placeholder[data-day="${dayIdx}"][data-period="${period}"]`
        );
    }
    // ✅ 파일에 이 버전 하나만 유지하세요 (중복 선언 제거!)
    function isTruthyTag(tag) {
        if (tag === true || tag === 1) return true; // boolean/number
        if (tag === false || tag === 0) return false;
        if (typeof tag === 'string') {
            const t = tag.trim().toLowerCase();
            // postgres 등에서 't'/'f'로 내려오는 경우 포함
            if (
                t === 't' ||
                t === 'true' ||
                t === '1' ||
                t === 'y' ||
                t === 'yes'
            )
                return true;
            if (
                t === 'f' ||
                t === 'false' ||
                t === '0' ||
                t === 'n' ||
                t === 'no'
            )
                return false;
        }
        return !!tag;
    }

    function pickTimetableArray(obj) {
        if (!obj || typeof obj !== 'object') return [];
        const candidates = Object.values(obj).filter(Array.isArray);
        return (
            candidates.find((arr) =>
                arr.some(
                    (r) =>
                        r &&
                        typeof r === 'object' &&
                        ('timetableId' in r || 'id' in r) &&
                        ('tag' in r || 'term' in r)
                )
            ) || []
        );
    }

    // "20252" -> "2025년 2학기"
    function toSemesterName(termCode) {
        const s = String(termCode || '');
        const year = s.slice(0, 4);
        const sem = s.slice(4);
        const label = sem === '1' ? '1학기' : sem === '2' ? '2학기' : '';
        return year && label ? `${year}년 ${label}` : '대표 시간표';
    }

    async function hydrateSemestersFromServer() {
        const token = localStorage.getItem('jwtToken');
        try {
            const res = await fetch('/tableId_List', {
                method: 'GET',
                headers: { Authorization: `Bearer ${token}` },
                credentials: 'include',
            });
            if (!res.ok)
                throw new Error(`시간표 목록 조회 실패 (HTTP ${res.status})`);
            const data = await res.json();

            const list = pickTimetableArray(data);
            if (!Array.isArray(list) || list.length === 0) return;

            selectedSemesters = [];
            timetableIdsBySemester = {};

            for (const row of list) {
                const term = String(row.term ?? row['term'] ?? '');
                const tid = Number(row.timeTableId ?? row['timetableId'] ?? row.id);
                const tagVal = row.tag ?? row['tag'];
                if (isTruthyTag(tagVal)) {
                    representativeTermCode = term; // ✅ 대표 학기 코드 상태 반영
                }

                if (!term || !tid) continue;

                timetableIdsBySemester[term] = tid;

                const semText = toSemesterName(term); // 이미 파일에 정의됨
                if (!selectedSemesters.includes(semText)) {
                    selectedSemesters.push(semText);
                }
            }

            renderSemesterList();
            populateSemesterSelectInline();
        } catch (err) {
            console.error('hydrateSemestersFromServer 오류:', err);
        }
    }

    async function removeSemester(termCode, timetableId) {
        if (!Number.isInteger(timetableId)) {
            alert('유효한 timetableId가 필요합니다.');
            return;
        }
        const token = localStorage.getItem('jwtToken');
        if (!confirm('이 학기의 시간표를 삭제할까요?')) return;

        try {
            // 서버 규약에 맞춰 호출 (지금은 /deleteTC 예시 그대로 사용)
            const res = await fetch('/deleteTC', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`,
                },
                body: JSON.stringify(timetableId),
            });

            const txt = await res.text();
            if (!res.ok) throw new Error(`삭제 실패: ${txt}`);

            // ✅ 로컬 상태에서도 제거
            const semText = toSemesterName(termCode);
            selectedSemesters = selectedSemesters.filter((s) => s !== semText);
            delete timetableIdsBySemester[termCode];
            renderSemesterList();
            alert('시간표가 삭제되었습니다.');
        } catch (err) {
            alert('삭제 중 오류 발생: ' + err.message);
            console.error(err);
        }
    }

    async function onToggleRepresentative(termCode, checked) {
        const token = localStorage.getItem('jwtToken');
        if (!checked) {
            // 해제는 허용하지 않음 → UI 되돌림
            renderSemesterList();
            return;
        }

        // 1) termCode -> timetableId 찾기
        const tid =
            timetableIdsBySemester?.[termCode] ??
            (await fetchLatestTimetableIdFromUserInfo(termCode));
        if (!tid) {
            alert('timetableId를 찾지 못했습니다.');
            renderSemesterList();
            return;
        }

        // 2) 대표로 설정
        const fd = new FormData();
        fd.append('timetableId', String(tid));
        const res = await fetch('/representative_Timetable', {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: fd,
        });
        if (!res.ok) {
            alert('대표 설정 실패');
            renderSemesterList();
            return;
        }

        // 3) 상태 반영 + 다시 렌더(서버 최신 반영)
        representativeTermCode = termCode;

        // ✅ 여기 부분이 핵심
        await hydrateSemestersFromServer(); // 목록/매핑 최신화
        await renderRepresentativeFromServer(); // 대표 시간표 재렌더
        renderSemesterList();
    }

    async function loadRepresentativeSchedule(getScheduleIds) {
        console.log(getScheduleIds);
        const token = localStorage.getItem('jwtToken');
        if (!token) {
            alert('로그인이 필요합니다.');
            return;
        }

        try {
            // 1) 서버 호출
            const res = await fetch('/getTS2TE', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`,
                },
                body: JSON.stringify({ getScheduleIds }),
            });

            if (!res.ok) throw new Error('대표 시간표 조회 실패');

            const data = await res.json(); // schedule_of_course[]
            console.log('대표시간표 데이터:', data);

            // 2) 테이블 생성
            renderRepresentativeSchedule(data);
        } catch (err) {
            console.error(err);
            alert('대표 시간표 로딩 중 오류 발생: ' + err.message);
        }
    }

    function renderRepresentativeSchedule(scheduleData){
        const container = document.getElementById('representativeScheduleContainer');
        if(!container) return;

        // 헤더는 그대로 두고, 바디만 grid-row span 버전으로 생성
        if(!document.getElementById('repGridBody')){
            container.innerHTML = `
      <div class="schedule-card" id="repGridCard">
        <div class="schedule-header">
          <div class="time-col"></div>
          <div>월</div><div>화</div><div>수</div><div>목</div><div>금</div>
        </div>
        <div class="schedule-body" id="repGridBody"></div>
      </div>`;
        }

        // 1) 초기 9교시로 그리드 생성
        buildRepGridSpan(9);

        const repGrid = document.getElementById('repGridSpanBody');
        if (repGrid) {
            repGrid.style.display = 'grid';
            repGrid.style.gridAutoFlow = 'row dense';
            repGrid.style.alignContent = 'start';
            repGrid.style.justifyContent = 'stretch';
            repGrid.style.gridAutoRows = '52px';
        }

        // 2) 필요한 만큼 아래로 확장
        let needMax = 9;
        scheduleData?.forEach(it=>{
            const e = Number(it.time_end ?? it.timeEnd ?? it.periodEnd ?? it.time_start ?? it.timeStart);
            if(Number.isFinite(e)) needMax = Math.max(needMax, e);
        });
        ensureRepGridSpanMax(needMax);

        // 3) 블록 배치
        scheduleData?.forEach(placeCourseBlockRep);
    }



    // ✅ 시간표 ID (부모)
    function getTid(r) {
        const v =
            r.timeTableId ??
            r.timetableId ??
            r.time_table_id ??
            r.timetable_id ??
            r.parentTimetableId ??
            r.timeTableIdOfParent ??
            r.tid;
        return v != null ? Number(v) : NaN;
    }

    // ✅ 코스 ID(= courseIds) → 당신이 말한 “scheduleIds 는 courseIds 여야 한다”를 구현하려면 이걸 사용
    function getCourseId(r) {
        return (
            r.courseId ??
            r.identifyNumberOfCourse ?? // 예: "HAEA0001-02"
            r.subjectCode ??
            r.course_id ??
            null
        );
    }

    async function renderRepresentativeFromServer() {
        const token = localStorage.getItem('jwtToken');
        if (!token) return;

        // ✅ UserId 보장
        if (!UserId) {
            try {
                await loaduserinfo();
            } catch (_) {}
        }

        // 1) 대표 timetableId/term 찾기
        const res = await fetch('/tableId_List', {
            method: 'GET',
            headers: { Authorization: `Bearer ${token}` },
            credentials: 'include',
        });
        if (!res.ok) return;

        const data = await res.json();
        const list = pickTimetableArray(data);
        const rep = list.find((row) => isTruthyTag(row.tag ?? row['tag']));

        if (!rep) {
            document.getElementById(
                'representativeScheduleContainer'
            ).innerHTML = `<p style="color:#888;">대표 시간표가 아직 설정되지 않았습니다.</p>`;
            document.getElementById('representativeTitle').textContent =
                '📌 대표 시간표';
            return;
        }

        const termCode = String(rep.term ?? rep['term'] ?? '');
        const timetableId = Number(
            rep.timeTableId ?? rep['timeTableId'] ?? rep.timetableId ?? rep.id
        );
        representativeTermCode = termCode;
        document.getElementById(
            'representativeTitle'
        ).textContent = `📌 대표 시간표 - ${toSemesterName(termCode)}`;

        // 2) 항상 userId로 /getTC 조회 → 해당 timetableId만 필터
        const byUid = await fetch('/getTC', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
            },
            // 서버가 지금까지 JSON.stringify(UserId) 형태를 받았으니 그대로 유지
            body: JSON.stringify(UserId),
        });
        if (!byUid.ok) {
            const failTxt = await byUid.text();
            console.error('getTC 실패 status=', byUid.status, 'body=', failTxt);
            document.getElementById(
                'representativeScheduleContainer'
            ).innerHTML = `<p style="color:#888;">대표 시간표를 불러오지 못했습니다.</p>`;
            return;
        }

        let all;
        try {
            const txt = await byUid.text();
            try {
                all = JSON.parse(txt);
            } catch (e) {
                console.error('[rep] /getTC JSON 파싱 실패. 원문:', txt);
                throw e;
            }
        } catch (e) {
            console.error('[rep] /getTC 응답 읽기 실패:', e);
            return;
        }
        console.log('[rep] /getTC 전체 rows:', all);
        console.log('[rep] 대표 timetableId(비교기준):', timetableId);

        const rows = (all || []).filter((r) => {
            const tid = getTid(r);
            return Number.isFinite(tid) && tid === timetableId;
        });
        console.log(
            '[rep] 대표 timetableId:',
            timetableId,
            '필터된 rows:',
            rows
        );

        // 3) scheduleIds 추출
        const courseIds = Array.from(
            new Set(
                rows.map(getCourseId).filter((v) => v != null && String(v).trim() !== '')
            )
        );
        console.log('[rep] 추출된 courseIds:', courseIds);
        // 4) /getTS2TE 호출 → 렌더
        await loadRepresentativeSchedule(courseIds);
    }
    function renderSlotHTML(subject, classroom, professor) {
        const sub = subject ?? "";
        const room = classroom ? `<div class="slot-room">${classroom}</div>` : "";
        return `
    <div class="slot">
      <div class="slot-title">${sub}</div>
      ${room}
    </div>
  `;
    }
    /** 대표 시간표용: grid-row span 가능한 바디를 그린다 */
    function buildRepGridSpan(periodCount = 9) {
        const body = document.getElementById('repGridBody');
        if (!body) return;
        body.innerHTML = '';

        // 하나의 grid 컨테이너로 행 전체를 구성
        const grid = document.createElement('div');
        grid.className = 'schedule-grid';
        grid.id = 'repGridSpanBody'; // 식별용

        // 각 교시 행 생성: 1열은 시간 라벨, 2~6열은 월~금 placeholder
        const labels = ['9~10시','10~11시','11~12시','12~1시','1~2시','2~3시','3~4시','4~5시','5~6시'];
        for (let p = 1; p <= periodCount; p++) {
            // 시간 셀
            const t = document.createElement('div');
            t.className = 'time-cell';
            t.style.gridColumn = '1';
            t.style.gridRow = String(p);
            t.innerHTML = `${p}교시<br/><span>${labels[p-1] || ''}</span>`;
            grid.appendChild(t);

            // 월~금 빈칸(격자선용)
            for (let day = 0; day < 5; day++) {
                const cell = document.createElement('div');
                cell.className = 'cell-placeholder';
                cell.dataset.day = String(day);
                cell.dataset.period = String(p);
                cell.style.gridColumn = String(day + 2); // 2..6
                cell.style.gridRow = String(p);
                grid.appendChild(cell);
            }
        }

        body.appendChild(grid);
    }

    /** 필요할 때 교시(행) 늘리기 */
    function ensureRepGridSpanMax(periodMax){
        const grid = document.getElementById('repGridSpanBody');
        if(!grid) return;
        const curRows = grid.querySelectorAll('[data-period]').length ?
            Math.max(...Array.from(grid.querySelectorAll('[data-period]')).map(e=>Number(e.dataset.period)||1))
            : 0;
        if(periodMax <= curRows) return;
        const labels = ['9~10시','10~11시','11~12시','12~1시','1~2시','2~3시','3~4시','4~5시','5~6시'];
        for(let p=curRows+1; p<=periodMax; p++){
            const t = document.createElement('div');
            t.className = 'time-cell';
            t.style.gridColumn = '1';
            t.style.gridRow = String(p);
            t.innerHTML = `${p}교시<br/><span>${labels[p-1] || ''}</span>`;
            grid.appendChild(t);
            for(let day=0; day<5; day++){
                const cell = document.createElement('div');
                cell.className = 'cell-placeholder';
                cell.dataset.day = String(day);
                cell.dataset.period = String(p);
                cell.style.gridColumn = String(day + 2);
                cell.style.gridRow = String(p);
                grid.appendChild(cell);
            }
        }
    }

    /** grid-row span을 사용하는 코스 블록 하나 추가 */
    function placeCourseBlockRep(item){
        const grid = document.getElementById('repGridSpanBody');
        if(!grid) return;

        const subject    = item.courseName || '';
        const professor  = item.professorName || '';
        const classroom  = item.classroom || '';
        const courseCode = item.identify_number_of_course ?? item.courseCode ?? item.identifyNumberOfCourse ?? subject;

        const dayIdx = (Number(item.day) || 0) - 1; // 0..4
        if (dayIdx < 0 || dayIdx > 4) return;

        const pStart = Number(item.time_start ?? item.timeStart ?? item.periodStart);
        const pEnd   = Number(item.time_end   ?? item.timeEnd   ?? item.periodEnd ?? pStart);
        if (!Number.isFinite(pStart) || !Number.isFinite(pEnd)) return;

        // 과목 색
        const bg = ColorManager.get(courseCode);

        // 블록 생성
        const block = document.createElement('div');
        block.className = 'course-block';
        block.style.gridColumn = String(dayIdx + 2);      // 2..6


        const repGrid = document.getElementById('repGridSpanBody');
        const sRow = gridRowForPeriod(repGrid, pStart);
        const eRow = gridRowForPeriod(repGrid, pEnd) + 1;
        block.style.gridRow = `${sRow} / ${eRow}`;


        block.style.setProperty('--course-color', bg);
        block.classList.add('busy');
        block.dataset.courseId = courseCode; // 추후 활용 가능

        block.innerHTML = renderSlotHTML(subject, classroom, professor);

        // (선택) 툴팁
        const tipData = {
            courseName: subject, professorName: professor, classroom,
            majorOrCulture: item.majorOrCulture ?? item.isMajor ?? null,
            credit: item.credit ?? '-', scheduleDay: Number(item.day),
            timeStart: pStart, timeEnd: pEnd, identifyNumberOfCourse: courseCode
        };
        block.onmouseenter = () => showCourseTooltip(block, tipData);
        block.onmouseleave = () => hideCourseTooltip();

        grid.appendChild(block);
        // === 블록 범위에 해당하는 placeholder의 가로줄 제거 ===
        for (let r = pStart; r <= pEnd; r++) {
            // 요일-교시 위치의 placeholder 찾기
            const ph = grid.querySelector(`.cell-placeholder[data-day="${dayIdx}"][data-period="${r}"]`);
            if (ph) {
                ph.style.borderBottom = 'none'; // ✅ 줄 없앰
            }
        }
    }
    // ✅ 추가: 모달용 grid-row span 테이블
    function generateModalGridSpanTable(maxPeriod = 9) {
        const days = ['월','화','수','목','금'];
        const labels = ['9~10시','10~11시','11~12시','12~1시','1~2시','2~3시','3~4시','4~5시','5~6시'];

        let grid = `
  <div class="schedule-card" id="scheduleTable">
    <div class="schedule-header">
      <div class="time-col"></div>
      ${days.map(d => `<div>${d}</div>`).join('')}
    </div>
    <div class="schedule-body">
      <div class="schedule-grid" id="modalGridSpanBody">
  `;

        for (let p = 1; p <= maxPeriod; p++) {
            // 시간 라벨
            grid += `
      <div class="time-cell" style="grid-column:1;grid-row:${p}">
        ${p}교시<br/><span>${labels[p-1] || ''}</span>
      </div>`;
            // 월~금 placeholder
            for (let day = 0; day < 5; day++) {
                grid += `
        <div class="cell-placeholder"
             data-day="${day}" data-period="${p}"
             style="grid-column:${day+2};grid-row:${p}"></div>`;
            }
        }

        grid += `</div></div></div>`;
        return grid;
    }
    // ✅ 추가: 모달 grid용 행 확장
    function ensureModalGridSpanMax(periodMax){
        const grid = document.getElementById('modalGridSpanBody');
        if(!grid) return;
        const curMax = Array.from(grid.querySelectorAll('.cell-placeholder'))
            .reduce((m,el)=>Math.max(m, Number(el.dataset.period)||1), 0);
        if (periodMax <= curMax) return;

        const labels = ['9~10시','10~11시','11~12시','12~1시','1~2시','2~3시','3~4시','4~5시','5~6시'];
        for (let p = curMax + 1; p <= periodMax; p++) {
            const t = document.createElement('div');
            t.className = 'time-cell';
            t.style.gridColumn = '1';
            t.style.gridRow    = String(p);
            t.innerHTML = `${p}교시<br/><span>${labels[p-1] || ''}</span>`;
            grid.appendChild(t);
            for (let day = 0; day < 5; day++) {
                const cell = document.createElement('div');
                cell.className = 'cell-placeholder';
                cell.dataset.day = String(day);
                cell.dataset.period = String(p);
                cell.style.gridColumn = String(day + 2);
                cell.style.gridRow    = String(p);
                grid.appendChild(cell);
            }
        }
    }
    function hasZeroPeriodGrid(grid) {
        return !!grid.querySelector('.cell-placeholder[data-period="0"]');
    }

    function prependZeroPeriodGrid(grid) {
        if (!grid) return;
        if (hasZeroPeriodGrid(grid)) return;

        // 1) 기존 요소들의 grid-row를 +1
        Array.from(grid.children).forEach(el => {
            const row = (el.style.gridRow || '').trim();
            if (!row) return;
            if (row.includes('/')) {
                const [s, e] = row.split('/').map(v => parseInt(v.trim(), 10));
                if (Number.isFinite(s) && Number.isFinite(e)) {
                    el.style.gridRow = `${s + 1} / ${e + 1}`;
                }
            } else {
                const n = parseInt(row, 10);
                if (Number.isFinite(n)) el.style.gridRow = String(n + 1);
            }
        });

        // 2) 새 0교시 time-cell + 월~금 placeholder 생성 (grid-row: 1)
        const frag = document.createDocumentFragment();

        const t = document.createElement('div');
        t.className = 'time-cell';
        t.style.gridColumn = '1';
        t.style.gridRow = '1';
        t.innerHTML = `0교시<br/><span>8~9시</span>`;
        frag.appendChild(t);

        for (let day = 0; day < 5; day++) {
            const cell = document.createElement('div');
            cell.className = 'cell-placeholder';
            cell.dataset.day = String(day);
            cell.dataset.period = '0';
            cell.style.gridColumn = String(day + 2);
            cell.style.gridRow = '1';
            frag.appendChild(cell);
        }

        // ✅ 실제로 그리드의 맨 앞에 삽입 (append가 아니라 prepend!)
        grid.prepend(frag);

        relabelTimeCells(grid);
    }


    /** grid 안에서 0교시가 '영구 배치'로 비어 있으면 0교시 행을 제거하고 나머지를 -1 올린다 */
    function removeZeroPeriodGridIfEmpty(grid) {
        if (!grid || !hasZeroPeriodGrid(grid)) return;

        // 0교시 placeholder 중 data-course-id가 하나라도 있으면 유지
        const used = Array.from(grid.querySelectorAll('.cell-placeholder[data-period="0"]'))
            .some(ph => ph.getAttribute('data-course-id'));
        if (used) return;

        // 모두 제거(0교시 타임셀 + placeholder)
        Array.from(grid.querySelectorAll('.time-cell, .cell-placeholder')).forEach(el => {
            if (el.dataset && el.dataset.period === '0') el.remove();
        });
        // 미리보기 블록이 남아있을 수 있으니 제거
        grid.querySelectorAll('.preview-block').forEach(el => el.remove());

        // 나머지 요소 grid-row -1 (time-cell, placeholder, course-block 포함)
        Array.from(grid.children).forEach(el => {
            const row = (el.style.gridRow || '').trim();
            if (!row) return;
            if (row.includes('/')) {
                const [s, e] = row.split('/').map(v => parseInt(v.trim(), 10));
                if (Number.isFinite(s) && Number.isFinite(e)) {
                    el.style.gridRow = `${s - 1} / ${e - 1}`;
                }
            } else {
                const n = parseInt(row, 10);
                if (Number.isFinite(n)) el.style.gridRow = String(n - 1);
            }
        });
        relabelTimeCells(grid);
    }

    /** period(정수)를 현재 그리드에서 실제 grid-row로 매핑 */
    function gridRowForPeriod(grid, period) {
        return hasZeroPeriodGrid(grid) ? (period + 1) : period;
    }
    // 기존: previewCourseOnSchedule(...) 안에서 테이블 방식만 처리
    // 교체: 그리드가 있으면 이 함수로 분기
    function previewCourseOnGrid(entries) {
        const grid = document.getElementById('modalGridSpanBody');
        if (!grid || !entries?.length) return;

        grid.querySelectorAll('.preview-block').forEach(b => b.remove());

        // 0교시 필요한지 검사 → 최상단에 '실제' 삽입
        const needsZero = entries.some(e => Number(e.timeStart) === 0 || Number(e.timeEnd) === 0);
        if (needsZero) prependZeroPeriodGrid(grid);

        // 아래로 확장
        let needMax = 9;
        entries.forEach(e => {
            const end = Number(e.timeEnd ?? e.periodEnd ?? e.timeStart);
            if (Number.isFinite(end)) needMax = Math.max(needMax, end);
        });
        ensureModalGridSpanMax(needMax);

        // 요일별로 시간 구간 merge (연강 1박스)
        const byDay = {};
        entries.forEach(e => {
            const d = N(e.scheduleDay, 0) - 1;
            const s = N(e.timeStart ?? e.periodStart, null);
            const t = N(e.timeEnd   ?? e.periodEnd   ?? e.timeStart, null);
            if (!(d >= 0 && d < 5) || !Number.isFinite(s) || !Number.isFinite(t)) return;
            (byDay[d] ||= []).push([s, t]);
        });

        Object.entries(byDay).forEach(([dStr, ranges]) => {
            const d = Number(dStr);
            ranges.sort((a,b) => a[0]-b[0]);

            // 인접(또는 겹침) 구간 병합
            const merged = [];
            let cur = null;
            for (const [s,t] of ranges) {
                if (!cur) cur = [s,t];
                else if (s <= cur[1] + 1) cur[1] = Math.max(cur[1], t);
                else { merged.push(cur); cur = [s,t]; }
            }
            if (cur) merged.push(cur);

            // 병합된 구간마다 1개의 프리뷰 블록 생성
            merged.forEach(([s,t]) => {
                const block = document.createElement('div');
                block.className = 'course-block preview-block';
                block.style.gridColumn = String(d + 2);
                const startRow = gridRowForPeriod(grid, s);
                const endRow   = gridRowForPeriod(grid, t) + 1;
                block.style.gridRow = `${startRow} / ${endRow}`;
                // 간단 텍스트(첫 엔트리 기준 과목/강의실)
                const base = entries[0];
                block.innerHTML = renderSlotHTML(base.courseName, base.classroom, base.professorName || '');
                grid.appendChild(block);
            });
        });

        // 프리뷰 세션 상태
        previewSession.zeroAdded ||= needsZero;
    }
    // ✅ 항상 숫자로 강제
    function N(v, fb=null){ const n = Number(v); return Number.isFinite(n) ? n : fb; }

    // ✅ 현재 grid 상태(0교시 유무)에 맞춰 time-cell 라벨 재계산
    function relabelTimeCells(grid){
        if(!grid) return;
        const labels = {
            0: '8~9시',
            1: '9~10시', 2: '10~11시', 3: '11~12시', 4: '12~1시',
            5: '1~2시', 6: '2~3시', 7: '3~4시', 8: '4~5시', 9: '5~6시'
        };
        grid.querySelectorAll('.time-cell').forEach(tc=>{
            const rowCss = tc.style.gridRow || '';
            // "start / end" 혹은 "row" 형태 모두 대응
            let row = null;
            if(rowCss.includes('/')) row = N(rowCss.split('/')[0], 1);
            else row = N(rowCss, 1);

            // gridRow -> period
            // 0교시가 있으면 row 1 => period 0, 그 외 period = row-1
            const period = hasZeroPeriodGrid(grid) ? (row - 1) : row;
            const title = period === 0 ? '0교시' : `${period}교시`;
            const sub = labels[period] || '';

            tc.innerHTML = `${title}<br/><span>${sub}</span>`;
        });
    }

</script>
</body>
</html>